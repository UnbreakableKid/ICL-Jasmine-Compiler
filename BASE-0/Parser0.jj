PARSER_BEGIN(Parser)

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;

/** ID lister. */
public class Parser {

  static final String DEFAULT_FOLDER = "BASE-0/files/%s.txt";

  /** Main entry point. */
  public static void main(String []args) {

        String filename = null;

        switch(args.length){
        case 0: break;
        case 1:
            System.out.println("Wrong arguments: "+args[0]+".\nTry '-c File_Name' to compile or just run to interpreter.");
            System.exit(1);
        case 2:
            if(!args[0].equalsIgnoreCase("-c") ){
                System.out.println("Flag '-c' expected to compile, but "+args[0]+" received");
                System.exit(1);
            }
            filename = String.format(DEFAULT_FOLDER,args[1]);
            break;
        default:
            System.out.println("Wrong arguments.\nTry '-c File_Name' to compile or just run to interpreter.");
            System.exit(1);
        }

        Parser parser;

        if(filename != null){
            try{
                parser = new Parser(new FileInputStream(filename));
            }
            catch(FileNotFoundException e){
                System.out.println(e.getMessage());
                System.exit(1);
                return;
            }
            compiler(parser,args[1]);
        }
        else{
            parser = new Parser(System.in);
            interpreter(parser);
        }
  }

  private static void compiler(Parser parser, String filename){
        Environment<Integer> env = new Environment<>();
        ASTNode exp;
        CodeBlock codeBlock = new CodeBlock();
        try{
            exp = parser.Start();
            exp.compile(codeBlock, env);
            codeBlock.dump(filename);
            //codeBlock.code.clear();
        }catch(Exception e) {System.out.println("Syntax Error!");}
  }

  private static void interpreter(Parser parser){
        Environment<Integer> env = new Environment<>();
        ASTNode exp;
        System.out.println("Interpreter:\n");
        while(true){
            try{
                exp = parser.Start();

                if(exp == null){
                    System.out.println("Shutting down...");
                    System.exit(1);
                }
                VInt x = (VInt) exp.eval(env);
                System.out.println(x.getval());
            } catch(Exception e){
                System.out.println("Syntax Error!");
                parser.ReInit(System.in);
            }
        }
  }
}

PARSER_END(Parser)

SKIP :
{
     "\t"
   | "\r"
   | " "

}

TOKEN :
{
  <Def : "def">
  |
  < In: "in" >
  |
  < End: "end" >
  |
  <EXIT: "quit"|"QUIT"|"Quit"|"exit"|"EXIT"|"Exit">
  |
  <NEW: "new">
  |
  <IF: "if">
  |
  <ELSE: "else">
  |
  <THEN: "then">
  |
  <WHILE: "while">
  |
  <DO: "do">
  |
  <PRINT: "print">
  |
  <PRINTLN: "println">
  |
   <BOOL : "true" | "false">
  |
  <DEREF : "!">
  |
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">

  |
    < OR : "||" >
  |
    < AND : "&&" >
  |
    < NOT: "~">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  <EL : "\n">
  |
  < EQ: "=" >
  |
  <EQUALS : "==">
  |
  <ASSIGN: ":=">

  |

  <SEMICOLON: ";" >
|
  < LEQ : "<=" >
|
  < BEQ: ">=" >
|
  < LT : "<" >
|
  < BT : ">" >
|
  < COLON : ":" >
|
  < FINAL: ";;">
}

ASTNode Start():
{ ASTNode t, t1;}
{

    <EXIT> {return null;}
    |

    t = Exp()  (<SEMICOLON> t1 = Exp() {t = new ASTSeq(t, t1);})* (<FINAL>)* (<EOF> | <EL>)

    { return t; }
}


ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
     t1=EA() (<EQUALS> t2 = EA() {t1 = new ASTEq(t1, t2);}| <ASSIGN> t2 = EA() {t1 = new ASTAssign(t1, t2);})?

     {return t1;}
}

ASTNode EA():
{ Token op;
  ASTNode t1, t2;
}
{
   t1=Term() ( ( op=<PLUS> | op=<MINUS>) t2=Term()
                  { if (op.kind == PLUS)
                         t1 = new ASTPlus(t1,t2);
                    else
                         t1 = new ASTMinus(t1,t2);
                  }
                )*
      { return t1; }
}

ASTNode Term() :
{
 Token op;
 ASTNode t1, t2;
}
{
     t1 = Fact() ( ( op=<TIMES> | op=<DIV> ) t2 = Fact()
 		 {
              if (op.kind == TIMES)
                  t1 = new ASTMul(t1,t2);
              else
                  t1 = new ASTDiv(t1,t2);
         }
		)*


     { return t1; } 
}

ASTNode Comp() :
{
  ASTNode t1, t2;
}
{
  t1 = Exp()
  (
    <EQ> t2 = Exp() { t1 = new ASTEq(t1,t2); }
   |<LT> t2 = Exp() { t1 = new ASTLess(t1,t2); }
   |<BT> t2 = Exp() { t1 = new ASTBigger(t1,t2); }
   |<LEQ> t2 = Exp() { t1 = new ASTLessOrEqual(t1,t2); }
   |<BEQ> t2 = Exp() { t1 = new ASTBiggerOrEqual(t1,t2); }
   |<AND>  t2 = Exp() { t1 = new ASTAnd(t1,t2); }
   |<OR> t2 = Exp() { t1 = new ASTOr(t1,t2); }
  )?
  {
    return t1;
  }
}

ASTNode Fact() :{
  Token n, m;
  ASTNode t, t1, t2 = null;
  Map<String, ASTNode> vars = new HashMap<>();
}
    {

        (

        <MINUS> n=<Num> {
                VInt z = new VInt(Integer.parseInt(n.image));
                z.v = -z.v;
                t = new ASTNum(z);

        }


        | n=<Num> {
                VInt z = new VInt(Integer.parseInt(n.image));
                t = new ASTNum(z);        }


        | n=<Id> {

          t = new ASTId(n.image);
        }
        |
        n=<BOOL> {t1 = new ASTBool(n);}
        |
        <NOT> t1=Fact() { t1=new ASTNot(t1);}
        |
        <IF> t = Comp() <THEN> t1 = Exp() (<ELSE> t2=Exp())? <End>
        {
        if(t2 != null)
            t = new ASTIf(t,t1,t2);
        else t = new ASTIf(t,t1,null);}

        |

        <WHILE> t1 = Comp() <DO> t2 = Exp() <End>{

            t = new ASTWhile(t1, t2);

        }
        |
        <NEW> t1 = Fact() {

            t = new ASTRef(t1);
        }
        |
        <DEREF> t1 = Fact() {

            t = new ASTDeref(t1);
        }
        |
         <Def> (n = <Id> <EQ> t1 = Exp()  {vars.put(n.image, t1);}) +  <In> t2 = Exp() <End> {

          t = new ASTDef(vars, t2);
        }
        | <LPAR> t=Exp() <RPAR> )
        { return t; }

    }
